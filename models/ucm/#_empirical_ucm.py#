"""
Empirical UCM: used when tho jacobian matrix is not known a-priori and should be estimated.
"""

from sklearn.decomposition import PCA
from sklearn.linear_model import LinearRegression
from sklearn.base import RegressorMixin


# TODO: this is very unnatural way to make the UCM.
# I want the attributes of the PCA class, but the methods of the
# LinearRegression class.

# It may be worth defining the UCM with the vague ideas I plan on implementing
# to be drawn out in more detail. THis is because, at the moment, I am not sure
# what exactly it is I want done in the case of, say, some jacobian estimation.



class UCMEmpirical(LSRegMixin, PCRegMixin, PLSRegMixin):
    """
    
    """

    def __init__(self):
        super(

    def _fit(self, X, y):

        X, y = self._validate_data(X,y)

    def fit(self, X, y):
        """
        Uses standard multiple regression between the elements X and
        the performance variable y to estimate the jacobian matrix.
        """
        # demean X
        X = X.copy() - np.mean(X, axis = 0)
        y = y.copy() - np.mean(y, axis = 0)
        
        # check to see if scaled data should be used
        if self._use_scaled_:
            X = self._scale_data(X)
            y = self._scale_data(y)
            
        # X and y have already been passed in the fit function
        # least-squares estimator of partial derivatives
        betas = linalg.pinv(X) @ y

        # setting jacobian
        self.j = betas

        # getting jacobian from the regression
        j_norm = self._check_j(betas)

        # getting results
        onb, dim_ort, dim_ucm = self._def_onb(j_norm)

        # score: R^2
        sse = sum(((X @ betas) - y)**2)
        sst = sum((y - np.mean(y))**2)
        score = 1 - (sse/sst)

        # changing _is_fitted_ internally
        self._is_fitted_ = True

        # reassignig computed values
        self.onb = onb
        self.dim_ort = dim_ort
        self.dim_ucm = dim_ucm
        self.score = score

        return self

    def fit_transform(self, X, y):
        """
        Fitting to data and producing synergy index results altogether at once
        """
        # fitting, then transforming.
        self.fit(X,y)
        self.transform(X)

        return self

    def _test(self, X, y = None):
        """
        EXPERIMENTAL HYPOTHESIS TEST FOR THE RESULTS
        """
        evls, evcs = np.eigh(np.cov(X.T))
